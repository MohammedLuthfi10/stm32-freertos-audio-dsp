/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body for the Inertial Audio Engine project.
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* ---------- CHANGED: use native FreeRTOS headers instead of CMSIS-RTOS wrapper */
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"
#include "stream_buffer.h"
#include "timers.h"
#include "queue.h"
/* -------------------------------------------------------------------------- */

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <string.h>
#include <stdint.h>
#include <math.h>

// NOTE: You will need to add the driver files for your specific
// audio codec and accelerometer to your project and include them here.
// #include "cs43l22.h"
// #include "lis3dsh.h"

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

// --- DSP Effect Definitions ---
typedef enum {
    EFFECT_BYPASS = 0,
    EFFECT_ECHO,
    EFFECT_FLANGER,
    EFFECT_TREMOLO,
    EFFECT_COUNT // Helper to count number of effects
} EffectType;

// Shared structure for effect parameters, controlled by motion
typedef struct {
    float param1; // e.g., Echo Delay Time, Flanger LFO Rate
    float param2; // e.g., Echo Feedback, Flanger LFO Depth
} DspParams;

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

// --- Audio Buffer Configuration ---
#define AUDIO_SAMPLING_RATE   48000
#define AUDIO_BLOCK_SAMPLES   256  // Number of int16_t samples in one processing block
#define AUDIO_BLOCK_BYTES     (AUDIO_BLOCK_SAMPLES * sizeof(int16_t))
#define DMA_BUFFER_SIZE       (AUDIO_BLOCK_SAMPLES * 2) // Double buffer size

// --- DSP State Variables ---
#define DELAY_BUFFER_SIZE   (AUDIO_SAMPLING_RATE * 2) // 2 seconds max delay for echo

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */
// --- Hardware Handles (Generated by CubeMX) ---
I2C_HandleTypeDef hi2c1;
I2S_HandleTypeDef hi2s2;
I2S_HandleTypeDef hi2s3;
SPI_HandleTypeDef hspi1;

// --- DMA Buffers (managed by HAL/DMA driver) ---
int16_t dma_input_buffer;
int16_t dma_output_buffer;

// --- DSP State Variables (internal to dspTask) ---
int16_t delay_buffer = {0};
uint32_t delay_write_index = 0;
float lfo_phase = 0.0f;

// --- Global Application State ---
DspParams g_dspParams;
volatile EffectType g_currentEffect = EFFECT_BYPASS;

/* ---------- CHANGED: FreeRTOS handle types ---------- */
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);
static void MX_I2S2_Init(void);
static void MX_I2S3_Init(void);
static void MX_SPI1_Init(void);
/* USER CODE BEGIN PFP */
void audioInputTask(void *argument);
void audioOutputTask(void *argument);
void dspTask(void *argument);
void sensorTask(void *argument);
void uiTask(void *argument);

void process_echo(int16_t* input, int16_t* output, uint32_t block_size);
void process_flanger(int16_t* input, int16_t* output, uint32_t block_size);
void process_tremolo(int16_t* input, int16_t* output, uint32_t block_size);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* ---------- CHANGED: FreeRTOS-specific handles ---------- */
TaskHandle_t audioInputTaskHandle;
TaskHandle_t audioOutputTaskHandle;
TaskHandle_t dspTaskHandle;
TaskHandle_t sensorTaskHandle;
TaskHandle_t uiTaskHandle;

StreamBufferHandle_t rawAudioStreamHandle;
StreamBufferHandle_t processedAudioStreamHandle;
SemaphoreHandle_t dspParamsMutexHandle;
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_I2C1_Init();
  MX_I2S2_Init();
  MX_I2S3_Init();
  MX_SPI1_Init();
  /* USER CODE BEGIN 2 */

  // Placeholder for board-specific hardware initialization
  // e.g., CS43L22_Init(...) and LIS3DSH_Init(...)

  /* USER CODE END 2 */

  /* ---------- CHANGED: Create FreeRTOS objects instead of CMSIS-RTOS wrapper ---------- */

  /* Create the mutex(es) */
  dspParamsMutexHandle = xSemaphoreCreateMutex();

  /* Create the stream/message buffers */
  // Stream buffer needs space for at least 2 audio blocks + a little extra
  rawAudioStreamHandle = xStreamBufferCreate(AUDIO_BLOCK_BYTES * 2 + 1, AUDIO_BLOCK_BYTES);
  processedAudioStreamHandle = xStreamBufferCreate(AUDIO_BLOCK_BYTES * 2 + 1, AUDIO_BLOCK_BYTES);

  /* Create the tasks */
  /* Note: original stack_size values in your CMSIS attrs were treated as bytes.
     FreeRTOS expects stack depth in words (portSTACK_TYPE). Convert roughly by /4. */

  {
    BaseType_t ret;
    /* audioInputTask: original stack_size 1024 -> 1024/4 = 256 words */
    ret = xTaskCreate(audioInputTask, "audioInputTask", 256, NULL, configMAX_PRIORITIES-1, &audioInputTaskHandle);
    (void)ret;
  }

  {
    BaseType_t ret;
    /* audioOutputTask: original stack_size 1024 -> 256 words */
    ret = xTaskCreate(audioOutputTask, "audioOutputTask", 256, NULL, configMAX_PRIORITIES-1, &audioOutputTaskHandle);
    (void)ret;
  }

  {
    BaseType_t ret;
    /* dspTask: original stack_size 4096 -> 4096/4 = 1024 words */
    ret = xTaskCreate(dspTask, "dspTask", 1024, NULL, configMAX_PRIORITIES-2, &dspTaskHandle);
    (void)ret;
  }

  {
    BaseType_t ret;
    /* sensorTask: original stack_size 1024 -> 256 words */
    ret = xTaskCreate(sensorTask, "sensorTask", 256, NULL, tskIDLE_PRIORITY+1, &sensorTaskHandle);
    (void)ret;
  }

  {
    BaseType_t ret;
    /* uiTask: original stack_size 512 -> 512/4 = 128 words */
    ret = xTaskCreate(uiTask, "uiTask", 128, NULL, tskIDLE_PRIORITY, &uiTaskHandle);
    (void)ret;
  }

  /* Start scheduler */
  vTaskStartScheduler();

  /* We should never get here as control is now taken by the scheduler */
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

//... All the MX_..._Init() functions generated by CubeMX go here...
//... (This part is omitted for brevity but is essential)...

/* USER CODE BEGIN 4 */

/**
  * @brief  This is the callback for the I2S DMA Receive operation.
  *         It is called from an interrupt context when the first half of the buffer is full.
  */
void HAL_I2S_RxHalfCpltCallback(I2S_HandleTypeDef *hi2s)
{
  BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  /* Signal the audioInputTask that the first half of the DMA buffer is ready */
  xTaskNotifyFromISR(audioInputTaskHandle, 0x01, eSetBits, &xHigherPriorityTaskWoken);
  portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

/**
  * @brief  This is the callback for the I2S DMA Receive operation.
  *         It is called from an interrupt context when the entire buffer is full.
  */
void HAL_I2S_RxCpltCallback(I2S_HandleTypeDef *hi2s)
{
  BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  /* Signal the audioInputTask that the second half of the DMA buffer is ready */
  xTaskNotifyFromISR(audioInputTaskHandle, 0x02, eSetBits, &xHigherPriorityTaskWoken);
  portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

/**
  * @brief  This is the callback for the I2S DMA Transmit operation.
  *         It is called when the first half of the output buffer has been sent.
  */
void HAL_I2S_TxHalfCpltCallback(I2S_HandleTypeDef *hi2s)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    /* Signal the audioOutputTask that the first half of the DMA buffer is free */
    xTaskNotifyFromISR(audioOutputTaskHandle, 0x01, eSetBits, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

/**
  * @brief  This is the callback for the I2S DMA Transmit operation.
  *         It is called when the entire output buffer has been sent.
  */
void HAL_I2S_TxCpltCallback(I2S_HandleTypeDef *hi2s)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    /* Signal the audioOutputTask that the second half of the DMA buffer is free */
    xTaskNotifyFromISR(audioOutputTaskHandle, 0x02, eSetBits, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

/**
  * @brief  This is the callback for External Interrupts (e.g., the user button).
  */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    if(GPIO_Pin == USER_Btn_Pin) // Check if the interrupt is from the user button
    {
        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
        /* Signal the uiTask that the button was pressed. */
        xTaskNotifyFromISR(uiTaskHandle, 0x01, eSetBits, &xHigherPriorityTaskWoken);
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    }
}


// --- TASK IMPLEMENTATIONS ---

/**
  * @brief  Audio Input Task: Manages DMA reception and sends raw audio to the DSP task.
  */
void audioInputTask(void *argument)
{
  /* Start the I2S receiver with DMA in circular mode.
     This function call starts the hardware process. */
  HAL_I2S_Receive_DMA(&hi2s2, (uint16_t*)dma_input_buffer, DMA_BUFFER_SIZE);

  for(;;)
  {
    uint32_t notifyValue = 0;
    /* Wait for a signal from one of the DMA interrupt callbacks */
    xTaskNotifyWait(0x00, 0xFFFFFFFF, &notifyValue, portMAX_DELAY);

    if (notifyValue & 0x01) // Half-complete interrupt
    {
      /* Send the first half of the DMA buffer to the DSP task via stream buffer */
      xStreamBufferSend(rawAudioStreamHandle, &dma_input_buffer, AUDIO_BLOCK_BYTES, 0);
    }
    if (notifyValue & 0x02) // Full-complete interrupt
    {
      /* Send the second half of the DMA buffer to the DSP task */
      xStreamBufferSend(rawAudioStreamHandle, &dma_input_buffer, AUDIO_BLOCK_BYTES, 0);
    }
  }
}

/**
  * @brief  Audio Output Task: Receives processed audio and manages DMA transmission.
  */
void audioOutputTask(void *argument)
{
  /* Fill the output buffer with silence initially */
  memset(dma_output_buffer, 0, DMA_BUFFER_SIZE * sizeof(int16_t));

  /* Start the I2S transmitter with DMA in circular mode */
  HAL_I2S_Transmit_DMA(&hi2s3, (uint16_t*)dma_output_buffer, DMA_BUFFER_SIZE);

  for(;;)
  {
    uint32_t notifyValue = 0;
    /* Wait for a signal that a DMA buffer half is free */
    xTaskNotifyWait(0x00, 0xFFFFFFFF, &notifyValue, portMAX_DELAY);

    if (notifyValue & 0x01) // First half is free
    {
      /* Block and wait for processed data from the DSP task */
      xStreamBufferReceive(processedAudioStreamHandle, &dma_output_buffer, AUDIO_BLOCK_BYTES, portMAX_DELAY);
    }
    if (notifyValue & 0x02) // Second half is free
    {
      /* Block and wait for processed data from the DSP task */
      xStreamBufferReceive(processedAudioStreamHandle, &dma_output_buffer, AUDIO_BLOCK_BYTES, portMAX_DELAY);
    }
  }
}

/**
  * @brief  DSP Task: The computational core of the application.
  */
void dspTask(void *argument)
{
  int16_t raw_block;
  int16_t processed_block;

  for(;;)
  {
    /* 1. BLOCK and wait for a full block of raw audio from the input task. */
    xStreamBufferReceive(rawAudioStreamHandle, &raw_block, AUDIO_BLOCK_BYTES, portMAX_DELAY);

    /* 2. Process the audio block based on the currently selected effect. */
    switch (g_currentEffect)
    {
      case EFFECT_ECHO:
        process_echo(&raw_block, &processed_block, AUDIO_BLOCK_SAMPLES);
        break;
      case EFFECT_FLANGER:
        process_flanger(&raw_block, &processed_block, AUDIO_BLOCK_SAMPLES);
        break;
      case EFFECT_TREMOLO:
        process_tremolo(&raw_block, &processed_block, AUDIO_BLOCK_SAMPLES);
        break;
      case EFFECT_BYPASS:
      default:
        /* In bypass mode, just copy input to output */
        memcpy(&processed_block, &raw_block, AUDIO_BLOCK_BYTES);
        break;
    }

    /* 3. Send the processed block to the output task. */
    xStreamBufferSend(processedAudioStreamHandle, &processed_block, AUDIO_BLOCK_BYTES, portMAX_DELAY);
  }
}

/**
  * @brief  Sensor Task: Periodically reads accelerometer data.
  */
void sensorTask(void *argument)
{
  float axes[1]; // To hold X, Y, Z values

  for(;;)
  {
    /* This is a placeholder for your accelerometer driver call */
    // LIS3DSH_ReadAxes(axes);

    /* Normalize accelerometer data (example, depends on sensor range)
       Assuming a range of -2g to +2g, and we want a 0.0 to 1.0 mapping */
    float x_norm = (axes / 2000.0f) + 0.5f; // Example scaling
    float y_norm = (axes[2] / 2000.0f) + 0.5f; // Example scaling

    /* Clamp values to be between 0.0 and 1.0 */
    if(x_norm < 0.0f) x_norm = 0.0f;
    if(x_norm > 1.0f) x_norm = 1.0f;
    if(y_norm < 0.0f) y_norm = 0.0f;
    if(y_norm > 1.0f) y_norm = 1.0f;

    /* Acquire mutex to safely update shared parameters */
    xSemaphoreTake(dspParamsMutexHandle, portMAX_DELAY);
    g_dspParams.param1 = x_norm;
    g_dspParams.param2 = y_norm;
    xSemaphoreGive(dspParamsMutexHandle);

    /* Wait for the next sample period */
    vTaskDelay(pdMS_TO_TICKS(50)); // Read sensor 20 times per second
  }
}

/**
  * @brief  UI Task: Monitors user button and controls LEDs.
  */
void uiTask(void *argument)
{
  TickType_t last_press_time = 0;

  for(;;)
  {
    uint32_t notifyValue = 0;
    /* Wait for a signal from the button interrupt */
    xTaskNotifyWait(0x00, 0xFFFFFFFF, &notifyValue, portMAX_DELAY);

    /* Simple debounce logic */
    if ((xTaskGetTickCount() - last_press_time) > pdMS_TO_TICKS(200)) // 200ms debounce
    {
      last_press_time = xTaskGetTickCount();

      /* Cycle to the next effect */
      g_currentEffect = (EffectType)((g_currentEffect + 1) % EFFECT_COUNT);

      /* Update LEDs to indicate current effect */
      HAL_GPIO_WritePin(GPIOD, LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin, GPIO_PIN_RESET);
      switch(g_currentEffect)
      {
        case EFFECT_BYPASS: break; // No LED
        case EFFECT_ECHO: HAL_GPIO_WritePin(GPIOD, LD4_Pin, GPIO_PIN_SET); break; // Green
        case EFFECT_FLANGER: HAL_GPIO_WritePin(GPIOD, LD3_Pin, GPIO_PIN_SET); break; // Orange
        case EFFECT_TREMOLO: HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_SET); break; // Red
        default: break;
      }
    }
  }
}


// --- DSP ALGORITHM IMPLEMENTATIONS ---

void process_echo(int16_t* input, int16_t* output, uint32_t block_size)
{
    DspParams local_params;
    xSemaphoreTake(dspParamsMutexHandle, portMAX_DELAY);
    local_params = g_dspParams;
    xSemaphoreGive(dspParamsMutexHandle);

    float delay_time_sec = 0.05f + local_params.param1 * 0.95f; // 50ms to 1s delay
    uint32_t delay_samples = (uint32_t)(delay_time_sec * AUDIO_SAMPLING_RATE);
    if (delay_samples >= DELAY_BUFFER_SIZE) delay_samples = DELAY_BUFFER_SIZE - 1;

    float feedback = local_params.param2 * 0.85f; // 0 to 85% feedback

    for (uint32_t i = 0; i < block_size; i++)
    {
        uint32_t read_index = (delay_write_index - delay_samples + DELAY_BUFFER_SIZE) % DELAY_BUFFER_SIZE;
        int16_t delayed_sample = delay_buffer[read_index];
        int32_t current_input = input[i];
        int32_t mixed_sample = current_input + (int32_t)(delayed_sample * feedback);

        /* Clip to prevent overflow before writing to delay line */
        if (mixed_sample > 32767) mixed_sample = 32767;
        if (mixed_sample < -32768) mixed_sample = -32768;
        delay_buffer[delay_write_index] = (int16_t)mixed_sample;

        delay_write_index = (delay_write_index + 1) % DELAY_BUFFER_SIZE;

        /* Final output is just the input + delayed sample (no feedback in output) */
        int32_t out_sample = current_input + delayed_sample;
        if (out_sample > 32767) out_sample = 32767;
        if (out_sample < -32768) out_sample = -32768;
        output[i] = (int16_t)out_sample;
    }
}

float get_lfo_value(float rate_hz, float depth)
{
    lfo_phase += (2.0f * M_PI * rate_hz) / AUDIO_SAMPLING_RATE;
    if (lfo_phase >= 2.0f * M_PI) {
        lfo_phase -= 2.0f * M_PI;
    }
    return sinf(lfo_phase) * depth;
}

void process_flanger(int16_t* input, int16_t* output, uint32_t block_size)
{
    DspParams local_params;
    xSemaphoreTake(dspParamsMutexHandle, portMAX_DELAY);
    local_params = g_dspParams;
    xSemaphoreGive(dspParamsMutexHandle);

    float lfo_rate_hz = 0.1f + local_params.param1 * 4.9f;
    float lfo_depth_sec = 0.001f + local_params.param2 * 0.005f; // 1ms to 6ms sweep

    for (uint32_t i = 0; i < block_size; i++)
    {
        float lfo_val = 0.5f + 0.5f * get_lfo_value(lfo_rate_hz, 1.0f);
        uint32_t delay_samples = (uint32_t)(lfo_val * lfo_depth_sec * AUDIO_SAMPLING_RATE);
        if (delay_samples >= DELAY_BUFFER_SIZE) delay_samples = DELAY_BUFFER_SIZE - 1;

        uint32_t read_index = (delay_write_index - delay_samples + DELAY_BUFFER_SIZE) % DELAY_BUFFER_SIZE;
        int16_t delayed_sample = delay_buffer[read_index];

        delay_buffer[delay_write_index] = input[i];
        delay_write_index = (delay_write_index + 1) % DELAY_BUFFER_SIZE;

        int32_t mixed_sample = (input[i] / 2) + (delayed_sample / 2);
        output[i] = (int16_t)mixed_sample;
    }
}

void process_tremolo(int16_t* input, int16_t* output, uint32_t block_size)
{
    DspParams local_params;
    xSemaphoreTake(dspParamsMutexHandle, portMAX_DELAY);
    local_params = g_dspParams;
    xSemaphoreGive(dspParamsMutexHandle);

    float lfo_rate_hz = 1.0f + local_params.param1 * 9.0f;
    float lfo_depth = local_params.param2;

    for (uint32_t i = 0; i < block_size; i++)
    {
        float lfo_val = get_lfo_value(lfo_rate_hz, 1.0f);
        float modulator = (1.0f - lfo_depth) + (lfo_depth * (lfo_val + 1.0f) * 0.5f);

        int32_t modulated_sample = (int32_t)(input[i] * modulator);
        if (modulated_sample > 32767) modulated_sample = 32767;
        if (modulated_sample < -32768) modulated_sample = -32768;
        output[i] = (int16_t)modulated_sample;
    }
}


/* USER CODE END 4 */

//... Rest of the file generated by CubeMX (SystemClock_Config, Error_Handler, etc.)...
